<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>19-函數作為參數傳遞</title>
</head>
<body>
  <script>

    // function add(num) {
    //   return num +10
    // }

    // function callFunc(a,b){
    //   return a(b)
    // }
    // let res = callFunc(add,10)
    // console.log(res);

    // function funct(num){
    //   if (num<=1) {
    //     return 1
    //   }else{
    //     return num * arguments.callee(num-1)
    //   }
    // }
    
    // let trueFunc = funct;
    // funct = function() { 
    //   return 0
    //  }
    
    // console.log(trueFunc);
    // console.log(funct);
    // console.log((trueFunc(5)));
    // console.log(funct(5));


    // this問題
    // function King() {
    //   this.name = '家輝'
    //   setTimeout(()=>{
    //     console.log(this.name);
    //     console.log(this === window);
    //   },1000)
    // }
    // King()
    // console.log(window.name);

    // var a = 0
    // var obj = {
    //   a:2,
    //   foo:function(){
    //     console.log(this);//ogj對象

    //     function test(){
    //       console.log(this);//window
    //     }
    //     test()
    //   }
    // }
    // obj.foo()



    // 參數賦值的情況
    // var a = 0
    // function foo(){
    //   console.log(this);//window
    // }
    // function bar(fn){
    //   fn()
      
    // }
    // var obj = {
    //   a:2,
    //   foo:foo
    // }
    // bar(obj.foo)

  /*   obj.foo就相當於是foo函數,把foo函數當作實參傳入bar函數裡面
    bar函數調用,但是裡面的fn函數就是foo函數,fn()=>foo(),也是獨立調用
    所以此時foo的this指向的是window */

    // var arr = [1,2,3]

    // pop,push方法
    // arr.push(4)
    // console.log(arr);
    // arr.pop()
    // console.log(arr);
    // arr.reverse()
    // console.log(arr);

    // shift方法
    // arr.shift()
    // console.log(arr);
    // arr.unshift(88)
    // console.log(arr);

    // splice方法

    // var arr = [1,2,3,4,5]
    // arr.splice(0,2,'anna') //第一位參數是數組的下標,第二個參數是截取的個數
    // 也就是從這一個下標開始,截取幾個
    // 第三個參數是截取之後需要替換的內容
    // arr.splice(1,0,100,200,300)
    // 這樣子就可以在不改變數組的情況下插入

    // console.log(arr);

    // var arr = [3,5,6,23,6,99]
    // arr.sort()
    // console.log(arr);
    
    // var arr = [2,'a',4,3,6,1]
    // arr.reverse()
    // arr.reverse()
    // arr.sort()
    // console.log(arr);


    // concat方法
    // concat方法不會改變原來的數組,而是返回一個新的數組
    // 原來的數組保持不變
    // var arr1 = [99,88,77]
    // var arr1 = arr1.concat(arr)
    // // console.log(newArr);
    // console.log(arr);
    // console.log(arr1);

    /* join方法,就是把裡面的每一項內容連接起來,變成一個字符串
    可以定義每一項之間的連接內容,拼接好之後返回一個拼接好的字符串
    join方法不會改變原來的數組 */
    // var arr = [1,2,4]
    // var str = arr.join('=')
    // console.log(str);
    // var str = arr.join('*')
    // console.log(str);

    // var arr = [1,2,4]
    // var str = arr.join('=')
    // console.log(str);
/* 
    用for方法一般來遍歷數組,,按照索引的方式進行遍歷
    因為對象沒有沒有下標索引,所以沒法用for方法來遍歷對象 */

    // 因此對象有它獨特的方法,for...in
    // var arr= [1,2,3,4,5,6]
    // for (let i = 0; i < arr.length; i++) {
    //   const element = arr[i];
    //   console.log(element);
      
    // }

    // var a = {
    //   name:'三七安',
    //   age: 19
    // }
    // // 下面使用for...in方法來遍歷
    // for (const key in a) {
    //   console.log(key);
    //   console.log(a[key]);
    // }

    // 冒泡排序

    // var arr = [4,6,3,7] // arr.length == 4
    // console.log(arr[5]);
    // for (let i = 0; i <= arr.length-1; i++) {
    //   // 第一層循環是躺輸,也就是要走arr.length-1趟才能比較完
    //   for (let j = 0; j <= arr.length-i-1; j++) {
    //     // 第二層循環是每一趟比較的次數,也就是
    //     // 每一輪我們都要比較arr.lenght-i次
    //     if (arr[j]>arr[j+1]) {
    //       var temp
    //       temp = arr[j]
    //       arr[j] = arr[j+1]
    //       arr[j+1] = temp
    //     }
    //   }
    // }
    // console.log(arr);

    // // 選擇排序
    //   var arr = [7,4,5,6,9]
    //   for(var j=0 ;j<arr.length-1;j++){ 
    //     var minIndex = j
    //       for(var i=j+1 ;i<arr.length;i++){
    //       //數組的最小下標,假設一地個就是最小的
    //       if (arr[i]<arr[minIndex]) {
    //         //如果後面的比前面的這個數還小,那麼就把這個下標存給minIndex
    //         minIndex = i
    //       }
    //     }
    //     // 一趟循環結束,就可以把數組中最小的數和第一個數交換
    //     var temp = arr[minIndex]
    //     arr[minIndex] = arr[j]
    //     arr[j] = temp
    //   }
    //   console.log(arr);


    // 選擇排序一輪
    var arr = [12,2,6,5]
    定義一個數組下標變量,初始化
    var minIndex = 0




    // function foo(){
    //   console.log(this === arr1);
    // }
    // var arr1 = [foo,1,2,3]
    // arr1[0]();
    


    // var newArr = [function a(){
    //   console.log(this.length);
    //   return 1
    // },function b(){
    //   console.log(this.length);
    //   return 2
    // }]
    // console.log(arr[0]);
    // arr[0]()












  </script>
</body>
</html>